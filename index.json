[
  {
    "url": "https://coq-tactician.github.io/manual/",
    "title": "Manual",
    "description": "",
    "content": ""
  },
  {
    "url": "https://coq-tactician.github.io/people/",
    "title": "People",
    "description": "",
    "content": "The following people are (or have been) involved in the development of Tactician (in no particular order):\nLasse Blaauwbroek (Maintainer) Josef Urban Herman Geuvers Jason Rute Miroslav Olšák Vasily Pestun Fidel I. Schaposnik Massolo Jelle Piepenbrock Liao Zhang Bartosz Piotrowski Cezary Kaliszyk "
  },
  {
    "url": "https://coq-tactician.github.io/publications/",
    "title": "Publications",
    "description": "",
    "content": " Graph2Tac: Learning Hierarchical Representations of Math Concepts in Theorem Proving\nAbstract: Concepts abound in mathematics and its applications. They vary greatly between subject areas, and new ones are introduced in each mathematical paper or application. A formal theory builds a hierarchy of definitions, theorems and proofs that reference each other. When an AI agent is proving a new theorem, most of the mathematical concepts and lemmas relevant to that theorem may have never been seen during training. This is especially true in the Coq proof assistant, which has a diverse library of Coq projects, each with its own definitions, lemmas, and even custom tactic procedures used to prove those lemmas. It is essential for agents to incorporate such new information into their knowledge base on the fly. We work towards this goal by utilizing a new, large-scale, graph-based dataset for machine learning in Coq. We leverage a faithful graph-representation of Coq terms that induces a directed graph of dependencies between definitions to create a novel graph neural network, Graph2Tac (G2T), that takes into account not only the current goal, but also the entire hierarchy of definitions that led to the current goal. G2T is an online model that is deeply integrated into the users\u0026rsquo; workflow and can adapt in real time to new Coq projects and their definitions. It complements well with other online models that learn in real time from new proof scripts. Our novel definition embedding task, which is trained to compute representations of mathematical concepts not seen during training, boosts the performance of the neural network to rival state-of-the-art k-nearest neighbor predictors.\nHashing Modulo Context-Sensitive α-Equivalence\nAbstract: The notion of α-equivalence between λ-terms is commonly used to identify terms that are considered equal. However, due to the primitive treatment of free variables, this notion falls short when comparing subterms occurring within a larger context. Depending on the usage of the Barendregt convention (choosing different variable names for all involved binders), it will equate either too few or too many subterms. We introduce a formal notion of context-sensitive α-equivalence, where two open terms can be compared within a context that resolves their free variables. We show that this equivalence coincides exactly with the notion of bisimulation equivalence. Furthermore, we present an efficient O(n log n) runtime algorithm that identifies λ-terms modulo context-sensitive α-equivalence, improving upon a previously established O(n log^2 n) bound for a hashing modulo ordinary α-equivalence by Maziarz et al. Hashing λ-terms is useful in many applications that require common subterm elimination and structure sharing. We employ the algorithm to obtain a large-scale, densely packed, interconnected graph of mathematical knowledge from the Coq proof assistant for machine learning purposes.\nThe Tactician\u0026rsquo;s Web of Large-Scale Formal Knowledge\nAbstract: The Tactician\u0026rsquo;s Web is a platform offering a large web of strongly interconnected, machine-checked, formal mathematical knowledge conveniently packaged for machine learning, analytics, and proof engineering. Built on top of the Coq proof assistant, the platform exports a dataset containing a wide variety of formal theories, presented as a web of definitions, theorems, proof terms, tactics, and proof states. Theories are encoded both as a semantic graph (rendered below) and as human-readable text, each with a unique set of advantages and disadvantages. Proving agents may interact with Coq through the same rich data representation and can be automatically benchmarked on a set of theorems. Tight integration with Coq provides the unique possibility to make agents available to proof engineers as practical tools.\nOnline Machine Learning Techniques for Coq: A Comparison\nAbstract: We present a comparison of several online machine learning techniques for tactical learning and proving in the Coq proof assistant. This work builds on top of Tactician, a plugin for Coq that learns from proofs written by the user to synthesize new proofs. Learning happens in an online manner, meaning that Tactician’s machine learning model is updated immediately every time the user performs a step in an interactive proof. This has important advantages compared to the more studied offline learning systems: (1) it provides the user with a seamless, interactive experience with Tactician and, (2) it takes advantage of locality of proof similarity, which means that proofs similar to the current proof are likely to be found close by. We implement two online methods, namely approximate k-nearest neighbors based on locality sensitive hashing forests and random decision forests. Additionally, we conduct experiments with gradient boosted trees in an offline setting using XGBoost. We compare the relative performance of Tactician using these three learning methods on Coq’s standard library.\nThe Tactician: A Seamless, Interactive Tactic Learner and Prover for Coq\nNote: An extended version of this paper is available on arXiv\nAbstract: We present Tactician, a tactic learner and prover for the Coq Proof Assistant. Tactician helps users make tactical proof decisions while they retain control over the general proof strategy. To this end, Tactician learns from previously written tactic scripts and gives users either suggestions about the next tactic to be executed or altogether takes over the burden of proof synthesis. Tactician’s goal is to provide users with a seamless, interactive, and intuitive experience together with robust and adaptive proof automation.\nTactic Learning and Proving for the Coq Proof Assistant\nAbstract: We present a system that utilizes machine learning for tactic proof search in the Coq Proof Assistant. In a similar vein as the TacticToe project for HOL4, our system predicts appropriate tactics and finds proofs in the form of tactic scripts. To do this, it learns from previous tactic scripts and how they are applied to proof states. The performance of the system is evaluated on the Coq Standard Library. Currently, our predictor can identify the correct tactic to be applied to a proof state 23.4% of the time. Our proof searcher can fully automatically prove 39.3% of the lemmas. When combined with the CoqHammer system, the two systems together prove 56.7% of the library’s lemmas.\n"
  },
  {
    "url": "https://coq-tactician.github.io/manual/quick/",
    "title": "Quick start",
    "description": "",
    "content": "This is a super-short guide for people with prior experience with Coq and Coq packages. If you\u0026rsquo;d like a more in-depth guide, see installation.\nInstallation opam install coq-tactician tactician enable # Optional but recoomended, adds Tactician to your coqrc tactician inject # Optional, instrument installation of Opam packages # For Coq \u0026lt; 8.17 only: opam install coq-tactician-stdlib # Optional, recompiles standard library Basic Usage If you have chosen to run tactician enable during installation, Tactician will be immediately ready to go. The two most important commands of Tactician are Suggest and synth. Both should be used in proof mode. You can try them out on our example file. A more comprehensive description of Tactician\u0026rsquo;s commands can be found in usage. To instrument packages with Tactician support, see Coq packages.\nGraph2Tac \u0026amp; Text2Tac In addition to Tactician\u0026rsquo;s default model, there are also external, neural proving agents available. See the page on Graph2Tac \u0026amp; Text2Tac for instructions.\n"
  },
  {
    "url": "https://coq-tactician.github.io/api/",
    "title": "API",
    "description": "",
    "content": ""
  },
  {
    "url": "https://coq-tactician.github.io/api/introduction/",
    "title": "API Introduction",
    "description": "",
    "content": " Tactician\u0026rsquo;s API provides external machine learning agents with Coq\u0026rsquo;s internal knowledge-base of mathematics. It can extract large-scale datasets from a wide variety of Coq packages for the purpose of offline machine learning. Additionally, it allows agents to interact with Coq. Proving servers can be connected to Tactician\u0026rsquo;s synth tactic and prove theorems for Coq users. Additionally, servers can do proof exploration through the Tactician Explore command. Examples of external proving agents include Graph2Tac \u0026amp; Text2Tac.\nThe data provided to agents includes definitions, theorems, proof terms and a machine-readable representation of tactical proofs. The data is provided both in Coq\u0026rsquo;s standard text-based human-readable format and as a semantic graph. The semantic graph is a single interconnected object that includes the entire mathematical universe known to Coq (at a given moment in time). As such, it provides external agents with \u0026ldquo;complete information\u0026rdquo; of Coq\u0026rsquo;s internal state, instead of \u0026ldquo;incomplete information\u0026rdquo;. The agent does not need to query Coq for information about theorems or definitions, because it has an always-up-to-date view.\nThe graph is designed to represent the semantic meaning of a mathematical object as faithfully as possible, minimizing the amount of implicit knowledge needed to interpret the object. For example, when a definition X refers to another definition Y, such a dependency is encoded explicitly using an edge in the graph. No definition lookup table is need. We also shy away from using names or de Bruijn indices as variables. Instead, variables point directly to their binders, so that name lookup becomes a trivial operation. Such an encoding reduces alpha-equivalence between terms to the graph-theoretic notion of bisimilarity, and allows us to globally deduplicate any alpha-equivalent terms in the graph.\nA simple example of the semantic graph is shown below. An entire Coq document is converted into a single graph. Alpha-equivalent sub-terms, such as 2* are globally shared. The graph includes all transitive objects referenced by the document, such as nat, =, + and * (shown with a truncated tree here).\nA zoomed-out view of the graph is visualized on the top of this page. This graph contains all information encoded in Coq\u0026rsquo;s Prelude. See the paper for details on the construction of the graph.\nCommunication with agents happens through the Cap\u0026rsquo;n Proto serialization format and remote procedure calling (RPC) protocol. It supports a wide variety of programming languages, including Python, OCaml, C++, Haskell, Rust and more. This serialization was chosen because it allows us to memory-map (mmap) large graph datasets, allowing fast random-access to graphs that may not fit into main memory. Furthermore, Cap\u0026rsquo;n Proto\u0026rsquo;s RPC protocol, based on the distributed object-capability model, allows us to export Coq\u0026rsquo;s proof states to external agents. Agents can inspect the proof states, and execute tactics on them, allowing exploration of the proof search space in arbitrary order.\nOverview of the platform Tactician\u0026rsquo;s API is meant to provide a bridge between the machine learning community and the proof engineering community. On the one hand, ML researchers can leverage the formal knowledge generated by proof engineers to build, train and evaluate agents. In return, these agents can be provided to proof engineers to assist them in synthesizing more formal knowledge. Agents can be integrated into the day-to-day workflow of proving and programming in Coq.\nComponents include:\nGraph2Tac \u0026amp; Text2Tac: Pre-trained models that can make tactic predictions and integrate with Tactician\u0026rsquo;s synth command. The first model uses the graph-based representation while the second model uses human-readable text. Datasets: Pre-made, large-scale datasets of formal knowledge extracted from a variety of Coq developments. Interactively explore the dataset here. The dataset includes hierarchies of modules, global context information, definitions, tactical proofs and tactic proof transformations. Coq Commands: Outlines the commands added to Tactician by the package coq-tactician-api for the purpose of interacting with external agents. PyTactician: A Python library build on top of Cap\u0026rsquo;n Proto to facilitate reading the dataset and interface with Coq. Benchmarking: Tools to evaluate the proving strength of agents on arbitrary Opam packages. Benchmarks can be run on a laptop, a high-powered server and even massively parallelized on a High Perfomance Computing (HPC) cluster. "
  },
  {
    "url": "https://coq-tactician.github.io/manual/installation/",
    "title": "Installation",
    "description": "",
    "content": "Windows We recommend that you install Tactician either in a virtual machine, or under the Windows Subsystem for Linux. Instructions for installing Coq in this environment can be found here. Further installation of Tactician is analogous to the Linux and macOS instructions\nAlternatively, we offer an experimental, unsigned installer based on Coq\u0026rsquo;s installer for Windows. Although all basic functionality works, this version is limited because it is difficult to impossible to install additional packages, and therefore it is also difficult to impossible for Tactician to learn from such packages.\nLinux and macOS Note: On macOS the instrumentation of packages currently only works in the development version of Tactician.\nBelow are detailed instructions to install Coq and Tactician through the Opam package manager. If you are already familiar with Coq and Opam, you can find a summary here.\nPrerequisites The installation of Coq and Tactician happens through Opam. If you already have a version of Coq installed through the package manager of your linux distribution you need to install a second version via Opam. The first step is to install Opam version 2.x through your favorite package manager. You can check that the installed version is newer than 2.0 by running opam --version. Some package managers do not yet include Opam 2.0. For Ubuntu 18.04 and higher a custom ppa is available. On other systems, you can use a binary installation script.\nAfter installation, some commands need to be executed to properly configure Opam. The following command will initialize Opam\u0026rsquo;s local state and will prompt you about installing hooks into your terminal that will automatically update your PATH to include binaries installed through Opam.\nopam init --bare # Answer yes to questions As the initialization script suggests, you might want to write source ~/.bash_profile in your ~/.bashrc file. Otherwise you wil have to run eval $(opam env) everytime you start Coq from a new terminal.\nNow you need to create a switch to install Coq and Tactician in:\nopam switch create coq-switch --empty eval $(opam env) This should be all that is required to prepare your system to install Coq and Tactician.\nInstallation of Tactician for Coq versions \u0026gt;= v8.17 To install Coq, Coqide (optional but recommended) and Tactician, run the following commands:\nopam repo add coq-released https://coq.inria.fr/opam/released opam install coq-core coq-tactician # Answer yes to all questions tactician inject opam install coq coqide On some exotic linux distibutions, the commands above may not know how to install system packages. In that case, you have to manually install them through your systems package manager, and then re-run these commands\nAfter installation, Tactician is not immediately enabled. This can be done by running the command tactician enable. This command will add some code to your coqrc file (a file that Coq loads automatically every time it is started) that will load Tactician. Further information about why Tactician is loaded this way can be found here. If you wish to disable Tactician, this can be done with the command tactician disable.\nTrying an example Tactician should now be ready to work. To make sure of this, you can test Tactician on an example file. First, start the Coq editor using the command\ncoqide \u0026amp; Then open the example file into the editor, and play around with it (moving around the document in CoqIde happens using the arrows at the top). Make sure that the two new commands provided by Tactician, Suggest and synth function properly.\nInstallation of Tactician for Coq versions \u0026lt; v8.17 For versions of Coq older than v8.17, there was no split between Coq\u0026rsquo;s core and standard library into the packages coq-core and coq-stdlib. This means that for those versions, Tactician is unable to inject itself into the build process of coq-stdlib, because of a circular dependency. Hence, it is unable to learn from the proofs available in the standard library.\nTo remedy this, a special package coq-tactician-stdlib was created, that recompiles the standard library with Tacticians instrumentation loaded. Warning: This will backup and overwrite Coq\u0026rsquo;s standard library. Upon removal of the package, the original files will be restored.\nopam repo add coq-released https://coq.inria.fr/opam/released opam install coq.8.16.1 coqide coq-tactician coq-tactician-stdlib # Answer yes to all questions tactician inject After installing coq-tactician-stdlib, Tactician has learned from the standard library and should be able to synthesize proofs regarding it.\n"
  },
  {
    "url": "https://coq-tactician.github.io/api/graph2tac/",
    "title": "Graph2Tac &amp; Text2Tac",
    "description": "",
    "content": "Graph2Tac is a novel neural network architecture for predicting appropriate tactics for proof states. The crucial innovation of Graph2Tac is that it can build an understanding of the math concepts in an entire Coq development and all of its dependencies on-the-fly. That is, it analyzes the structure of definitions and lemmas and builds an internal representation of each object in the global context. Then, when presented with a proof state that references these mathematical concepts, Graph2Tac can leverage its deep knowledge to predict tactics and arguments.\nText2Tac is a language model for synthesizing tactics. It receives the current proof state as a human-readable prompt and \u0026ldquo;completes\u0026rdquo; this prompt by synthesizing a tactic.\nComparison in capabilities of Graph2Tac, Text2Tac and Tactician\u0026rsquo;s default k-NN model:\nRepresentations: Graph2Tac is the only model that has deep background knowledge of the mathematical concepts in a library. Text2Tac and k-NN are informed only by the current proof state. References to objects in the global context are not resolved. Tactic prediction: All three models predict tactics in different ways, with unique advantages and disadvantages. Text2Tac is capable, at least in principle, of generating completely free-form tactic expressions. However, because it has no knowledge of the tactics and lemmas currently available in Coq, it is forced to \u0026ldquo;hallucinate\u0026rdquo; tactics. Graph2Tac, takes a more structured approach in generating tactics. It first chooses a \u0026ldquo;base\u0026rdquo; tactic, without any arguments, from a pre-defined set. For example, apply _. Then, it predicts an argument for each \u0026ldquo;hole\u0026rdquo; in the tactic. Arguments are pointers into the knowledge graph given to the model. Therefore, arguments are always valid objects. A downside is that Graph2Tac is unable to synthesize arbitrary terms as arguments. It is also incapable of leveraging previously unseen tactics defined by users. The k-NN model sees tactics and their arguments as a black box. It is only capable of predicting the exact tactic and argument combinations that already exist in its database. However, this model is capable of learning from previous proof scripts on-the-fly. This is rather powerful in practice, because it can learn to use new user-defined tactics and can \u0026ldquo;borrow\u0026rdquo; script fragments from similar proofs defined close-by. Speed: The k-NN model is two order of magnitude faster than Graph2Tac, which in turn is an order of magnitude faster than Text2Tac. Below is an overview of how Graph2Tac is trained to create definition embeddings and predict tactics and arguments. See the paper for more information on the architecture and performance of these models.\nInstallation Graph2Tac and Text2Tac are proving agents implemented in Python. It is highly recommended that you use a virtual environment or conda environment to install them.\nGraph2Tac is compatible with Python 3.9-3.11, while Text2Tac is compatible with Python 3.9-3.10. Install one (or both) of the agents using:\npip install graph2tac==1.0.4 pip install text2tac==1.0.1 Make sure that whenever you start Coq, the virtualenv where you made the installation is available in your PATH.\nPre-trained models compatible with these agents are available in the Opam packages coq-graph2tac and coq-text2tac. These packages contain all configuration details needed to make Tactician interface with the agents. For installation Opam \u0026gt;= 2.1 is recommended. Opam will prompt you to install Cap\u0026rsquo;n Proto and XXHash through you system package manager. If your system does not readily provide these packages, please consult the prerequisites page on Github for alternatives.\nMake sure that you have an Opam switch available with the Coq repositories available. For example, you can create one as follows:\nopam switch create tactician ocaml-base-compiler.4.11.2 --repos=custom-archive=git+https://github.com/LasseBlaauwbroek/custom-archive.git,coq-released=https://coq.inria.fr/opam/released,default (This command includes the custom-archive repo, which contains some bugfixes for Coq. This is optional. Note for MacOS: On MacOS, you will encounter bugs with ocaml-base-compiler.4.11.2. You must use ocaml-base-compiler.4.12.1.\nThen run either one of these commands (you cannot run both; coq-graph2tac and coq-text2tac are mutually incompatible).\nopam install coq-graph2tac coq-tactician-stdlib opam install coq-text2tac coq-tactician-stdlib If you which to instrument packages beyond Coq\u0026rsquo;s stdlib, the following command will inject Tactician in Opam\u0026rsquo;s compilation process. You can then install additional packages as normal.\ntactician inject Usage Whenever you perform any command-line actions that involve Coq while you wish to use Graph2Tac or Text2Tac, you have to prefix those commands with tactician exec. This will ensure that everything is loaded correctly. For example, you do this when starting your editor or when building a project using dune or make:\ntactician exec -- coqc ... tactician exec -- coqide ... tactician exec -- make ... tactician exec -- dune build ... tactician exec -- emacs ... Usage of Graph2Tac and Text2Tac is similar to the usage of Tactician\u0026rsquo;s default model. You can ask the model for Suggestions and ask it to synthesize proofs. More detailed descriptions of Tactician\u0026rsquo;s tactics are commands are in the manual.\nThere is one important additional command to use. Tactician\u0026rsquo;s API synchronizes Coq\u0026rsquo;s entire global context with the external agent when it starts a proof search. This can be an expensive operation. However, it is possible to introduce cache points in a document, where the global context is proactively synchronized with the agent. After a cache point, only new items in the global context need to be synchronized. This greatly speeds up initialization of a prediction. Creating a cache point is done using\nTactician Neural Cache. Alternatively, you can automatically create new cache points after every new Coq command using the option\nSet Tactician Autocache. Example Start CoqIDE through tactician exec coqide, and try the following example:\nFrom Tactician Require Import Ltac1. (* Set Tactician to automatically introduce external caching points *) Set Tactician Neural Autocache. Inductive mynat : Set := | my0 : mynat | myS : mynat -\u0026gt; mynat. Fixpoint myadd n m := match n with | my0 =\u0026gt; m | myS n =\u0026gt; myS (n + m) end where \u0026#34;n + m\u0026#34; := (myadd n m). Lemma my_comm : forall n m, n + m = m + n. Proof. (* Commutativity requires three separate inductions. That is too much. But Graph2Tac can do the inductions separately. Text2Tac cannot. *) induction n. - synth. - synth. Qed. "
  },
  {
    "url": "https://coq-tactician.github.io/manual/usage/",
    "title": "Usage",
    "description": "",
    "content": "After installation, it is easy to get started with Tactician. There are only two important commands, described in the section below. Below, we assume that you have executed tactician enable, so that Tactician is active when you start a new interactive document. You can try the commands below on our example file.\nBasic commands Suggest is a query that will—as its name implies—suggest a list of tactics that may be useful to progress in the current proof state of your lemma. You can simply copy them into your interactive document and run them as any other tactic. It is not recommended to permanently keep the query Suggest in your developments.\nsynth is a tactic that will try to synthesize a complete proof of the current goal. It does this based on the same suggestions as issued by Suggest. This tactic will run for as long as you let it, so when you run out of patience you might want to hit the \u0026lsquo;interrupt\u0026rsquo; button in your editor. When the tactic finds a proof, two things will happen.\nThe current goal will be finished, allowing you to move on to the next branch of the proof. This is convenient when you want to progress through the proof quickly and without any hassle.\nTactician will issue a caching tactic witness of the form\nsynth with cache (t1; t2; ..; tn). You can copy this witness, and replace the original invocation of synth with it. The result will be that the next time you execute this command, the system will first try to execute the provided witness. If this succeeds, the command will quickly terminate so that you do not have to wait for Tactician to prove goals time and time again while you navigate through an interactive document.\nOn the other hand, if the tactic witness turns out to be invalid (presumably due to a change in a definition or the statement of the current lemma), a new proof search will automatically be initiated to attempt a recovery of the witness.\nAuxiliary commands and usages In addition to Suggest and synth, we provide the following commands for more advanced use-cases.\nDebug Suggest and debug synth are variations of the commands above that will output debugging information.\ntactician ignore tac will execute the tactic tac, but while hiding it from Tacticians machine learning component. This can be useful when you use a tactic you know will confuse Tactician. One example is the unsafe tactic change_no_check, which allows the system to easily prove any proof state it wants. Note that Tactician will automatically ignore admit.\nIt is important to note that tactician ignore is not guaranteed to hide a tactic from Tactician when used as part of a larger tactic expression. For example, for the tactic expression\nsolve [tactician ignore constructor; auto]. it is guaranteed that the system will not learn from the individual tactic constructor. However, this tactic may or may not be used by Tactician as part of the larger expression. Whether or not this will happen depends on the version of Tactician and its internal settings.\nUnset Tactician Record will disable any further tactic recording for machine learning purposes by tactician. This can later be re-enabled with Set Tactician Record. Disabling Tactician can be useful when you want to define and prove some lemmas you do not want Tactician to know about. Another useful idiom is\nUnset Tactician Record. Require Import SecretLibrary. Set Tactician Record. This will hide all the contents of SecretLibrary from Tactician.\nIt is possible and sometimes useful to perform nested invocations of synth. By default, Tactician will refrain from learning from its own commands, such as synth. However, this is not the case when you use it as part of a tactic expression. An example is the expression\nsolve [constructor; synth]. When you execute this tactic, the synth command will be part of Ltac\u0026rsquo;s backtracking behavior, as expected. Additionally, Tactician will pick up the whole expression as a future way to prove a goal. As such, when you next execute synth, Tactician may start to nest these invocations with backtracking behavior. To keep this under control, nested search is bound to a depth of one.\nIf you execute the command above, but do not want Tactician to start doing nested searches, you might want to wrap it in tactician ignore:\ntactician ignore solve [constructor; synth]. "
  },
  {
    "url": "https://coq-tactician.github.io/manual/coq-packages/",
    "title": "Coq packages",
    "description": "",
    "content": "Tactician has first-class support for packages installed through the Opam package manager. Below we explain how to install Coq packages in such a way that Tactician can learn from its contents. We also give recommendations on packaging your own development when you use Tactician in this development.\nInstrumenting Coq packages To instrument packages such that Tactician can learn from them during compilation/installation, you simply execute the following command:\ntactician inject After that, almost any package installed through opam install will be instrumented. There are some exceptions, such as developments that come with their own standard library. For these developments special support can be built into Tactician. Currently, there is special support for these packages:\ncoq-hott If your favorite package cannot currently be instrumented, please open an issue.\nIf at any point you want to remove Tactician instrumentation from the build process, you can run tactician eject. This command will also help you recompile your currently installed packages to remove Tactician support.\nNote: On macOS, due to limitations of the operating system, some packages cannot be instrumented. Currently only coq-hott is known not to work.\nPackaging developments while using Tactician When you work on a Coq development that is intended to be packaged with Opam, we recommend that you do not create a hard dependency on the coq-tactician package. This will create an unnecessary burden on your users, who might not want to use Tactician. For this reason, it is recommended that you enable Tactician in your day-to-day work by loading it through your coqrc file. The command tactician enable will help you with this.\nThis does leave the question how users can compile Tactician\u0026rsquo;s commands not having Tactician installed. To resolve this, your package can depend on coq-tactician-dummy (or you can just copy this 12 line file into your development). You can load this package using\nFrom Tactician Require Import Ltac1Dummy. The dummy package contains trivial implementations of Tactician commands. In particular:\nsynth will generate an error. You should modify all instances of synth to include the generated witness of the form synth with cache tac. The dummy version will try to use the witness, but does not perform a new proof search when the witness fails. The tactic tactician ignore tac is simply a wrapper for tac. The option Unset Tactician Record will do nothing. However, it will generate a warning. If you want to ignore this warning, you can surround these commands as follows: Set Warnings \u0026#34;-unknown-option\u0026#34;. Unset Tactician Record. Set Warnings \u0026#34;unknown-option\u0026#34;. Suggest is not functional, and you should not keep this command in your development when you release it. "
  },
  {
    "url": "https://coq-tactician.github.io/api/commands/",
    "title": "Coq Commands",
    "description": "",
    "content": "The package coq-tactician-api makes some commands available in addition to the usual commands listed in the manual. You should install this package when you wish to build your own external agent. (Both Graph2Tac and Text2Tac depend on this package.)\nGraph Visualizations These commands will create a graph of some object, and write it to graph.pdf (if graphviz is available).\nThe following commands are always available:\n[Shared] Graph [Depth \u0026lt;n\u0026gt;] Ident identifier. [Shared] Graph [Depth \u0026lt;n\u0026gt;] Term term. The normal commands print a fully transitive graph. Adding Depth i limits the traversal to visiting at most i nested definitions.\nAdditionally, in proof mode, these commands are available:\n[Shared] Graph [Depth \u0026lt;n\u0026gt;] Proof. Options that modify the graphs generated by the commands above are\n[Set | Unset] Tactician Neural Visualize Ordered. [Set | Unset] Tactician Neural Visualize Labels. [Set | Unset] Tactician Neural Visualize Hashes. Interaction with synth In order to connect Tactician\u0026rsquo;s synth tactic to a external tactic prediction server like the dummy pytact-server described provided by PyTactician, the plugin makes a number of commands and settings available in Coq. In order to load the plugin, Coq needs to be started appropriately. This can be done by prefixing every invocation of a command that uses Coq, like coqc, coqide, a make command or an editor like emacs with tactician exec:\ntactician exec -- coqc ... tactician exec -- coqide ... tactician exec -- make ... tactician exec -- dune build ... tactician exec -- emacs ... To make the synth command available, your Coq file will have to start with\nFrom Tactician Require Import Ltac1. The following settings govern the data that Coq will send to the server:\nSet Tactician Neural Textmode determines wether Coq is communicating with a graph-based server or a text-based server (graph-based by default). Set Tactician Neural Metadata adds text-based metadata to when communicating in graph-mode, such as hypothesis names, textual representation of proof states and textual representations of definition. This will slow down the communication protocol, and should only be enabled for debugging, or when otherwise needed. To let Coq take care of starting and stopping the server, use the command\nSet Tactician Neural Executable \u0026#34;external-server-executable --argument1 --argument2\u0026#34;. If you have a prediction server already running somewhere over TCP, you can make Coq connect to it using\nSet Tactician Neural Server \u0026#34;\u0026lt;address\u0026gt;:\u0026lt;port\u0026gt;\u0026#34;. At this point, you have the following commands available which will interact with the server:\nTactician Neural Alignment will ask the which tactics and definitions currently in scope are unknown to it. This is meant as a sanity check. Suggest and Debug Suggest will ask the server for predictions for the current proof state. synth and debug synth will perform a proof search by repeatedly asking the server for predictions. Tactician Neural Cache will preemptively send a lot of required data to the prediction server and keeps that information cached. This will make the commands above run much faster. This command can be issued multiple times in a document, creating multiple nested caches. Set Tactician Autocache will automatically execute Tactician Neural Cache on each command. This is an experimental option, and there may be some overhead associated with this. Client-based proof exploration Finally, the command Tactician Explore. will initiate a proof exploration session. An example of this is available in TestReinforceStdin.v. To do this, you need to have a python client running. An example is available in the pytact-prover executable. To see how it works, run pytact-prover --pdfsequence --pdfname test This will execute a dummy proof through the proof exploration interface. Visualizations of each proof state are available in test\u0026lt;n\u0026gt;.pdf. optionally --file option to point to a source Coq .v file. Also with --interactive option the interactive shell appears where you can manually interact with the environment. Whenever a tactic is executed, the resulting proof state if visualized in the file python_graph.pdf.\n"
  },
  {
    "url": "https://coq-tactician.github.io/api/pytactician/",
    "title": "PyTactician",
    "description": "",
    "content": "PyTactician is a library to help write proving agents and explore datasets. The major version number x of this library indicates the version of the dataset and communication protocol. Any PyTactician version x.y is compatible with the communication protocol x.\nInstallation Binary wheels are provided for Linux and MacOS (on PyPI). On those platforms you can install by executing pip install pytactician. If you need to install from source, you need to have Cap\u0026rsquo;n Proto \u0026gt;= 0.8 installed on your system. See the main repo README for more details on prerequisites. Once you have the prerequisites, you can install by running pip install . from the root of the repository.\nUsage PyTactician provides a library to work with the datasets extracted from Coq and to directly interface with Coq through Tacticians API.\nPyTactician Library Documentation. To get started quickly, there are some simple example scripts that interface with the dataset. In addition, PyTactician contains a number of executables that can be used to analyze datasets and interact with Coq. Available executables are as follows (use the --help flag for each executable to learn about all the options).\npytact-check [-h] [--jobs JOBS] [--quick] [--verbose VERBOSE] dir Run sanity checks on a dataset and print some statistics. pytact-visualize [-h] [--port PORT] [--hostname HOSTNAME] [--dev] [--fast | --workers WORKERS] dataset: Start an interactive server that visualizes a dataset. pytact-server [-h] [--tcp TCP] [--record RECORD_FILE] {graph,text} Example python server capable of communicating with Coq through Tactician\u0026rsquo;s \u0026lsquo;synth\u0026rsquo; tactic To learn how to interface Coq and Tactician with this server, see the sections below. pytact-oracle [-h] [--tcp PORT] [--record RECORD_FILE] {graph,text} dataset A tactic prediction server acting as an oracle, retrieving it\u0026rsquo;s information from a dataset pytact-fake-coq [-h] (--tcp TCP_LOCATION | --stdin EXECUTABLE) data A fake Coq client that connects to a prediction server and feeds it a stream of previously recorded messages. pytact-prover: A dummy example client that interfaces with Coq and Tactician for proof exploration driven by the client. "
  },
  {
    "url": "https://coq-tactician.github.io/api/datasets/",
    "title": "Datasets",
    "description": "",
    "content": "Online Data Explorer You can explore and visualize the latest dataset that has been extracted from Coq online. The visualization should give you some intuition about what kind of data is available and how it is encoded. If this data is interesting to you, you can find download and usage instructions below.\nYou can find the main entry-point for the visualization here. From there, you can explore the entire dataset. Examples of objects include:\nModule hierarchies showing dependencies between compilation units Global contexts of a compilation units Individual definitions within a global context Tactical proofs of theorems Individual Proof transformations of tactical proofs Downloads Datasets are published on Zenodo:\nData for API v15 on Coq v8.11 Accessing the data The data is encoded using the Cap\u0026rsquo;n Proto serialization protocol, allowing for fast random access to the graph and metadata from many programming languages. For Python, a library called PyTactician is provided that allows for easy and efficient access to the data. It includes software to visualize the dataset, a sanity checker for the dataset, an example prediction server that interfaces with Coq, an Oracle prediction server and an example proof exploration client. This library is a good starting point to explore the dataset. If you are looking to use another language to access the data, your starting point would be the graph_api.capnp schema file.\nThe data in the archive is represented as a SquashFS image dataset.squ. In order to access the data, you can either mount it or decompress it. Mounting is preferred on machines with limited memory. To mount, you need to install squashfuse through your favorite package manager.\nNote for MacOS users: Squashfuse is not available on MacOS. You can instead install squashfs from Brew and decompress the dataset using the unsquashfs instructions below.\nOnce squashfuse is installed, if you are using PyTactician, you can load the dataset by pointing directly to this image. This will automatically mount the image in directory dataset/. For example:\npytact-check dataset.squ pytact-visualize dataset.squ If you prefer to mount manually, or if you are not using the PyTactician library, you can mount the image using\nsquashfuse dataset.squ dataset/ pytact-check dataset/ pytact-visualize dataset/ umount dataset/ # Unmount the dataset, optional Finally, you can also unpack the image without mounting it (this is the only option for MacOS). On systems with limited memory or slow hard-disks this will lead to some performance degradations while accessing the dataset. If you wish to unpack, you can run:\nunsquashfs -dest dataset/ dataset.squ Introspecting the dataset with PyTactician You can use PyTactician as a library to write scripts that extract information from the dataset. To get started, you can take a look at some simple example scripts. Documentation of the API is also available.\nRaw data inspection For each Coq compilation unit X, the dataset includes the original X.v source file. Alongside that file is a X.bin file with Cap\u0026rsquo;n Proto structure containing the data extracted during the compilation of X.\nIf you wish to inspect the raw data in the dataset manually, you can use capnp convert to decode an individual file in the dataset to JSON as follows:\ncat dataset/coq-tactician-stdlib.8.11.dev/theories/Init/Logic.bin | \\ capnp convert binary:json meta/graph_api.capnp Dataset You can process the resulting JSON further using, for example, the jq command.\n"
  },
  {
    "url": "https://coq-tactician.github.io/faq/",
    "title": "About Tactician",
    "description": "",
    "content": "\rWhat is Tactician?\rTactician is a tactic learner and prover for the Coq Proof Assistant. The system will help users make tactical proof decisions while they retain control over the general proof strategy. To this end, Tactician will learn from previously written tactic scripts, and either gives the user suggestions about the next tactic to be executed or altogether takes over the burden of proof synthesis. Tactician\u0026rsquo;s goal is to provide the user with a seamless, interactive, and intuitive experience together with strong, adaptive proof automation.\nCan I use Tactician in a complex project with many dependencies?\rYes, the system has first-class support for Opam, Coq\u0026rsquo;s package manager. When you install dependencies, Tactician can automatically instrument those developments and learn from them. When you work on your project, Tactician will have background knowledge on all modules you Require.\nOn the flip side, using Tactician in your project does not mean you now have a hard dependency on Tactician. When the system finds a proof, it presents you with a caching witness that you can copy into your source file. As long as this witness remains valid, you can compile your project without having the main Tactician code-base installed. You only need 10 lines of helper tactics, which you can install through the coq-tactician-dummy package, or simply copy them into your development.\nIs Tactician useful for teaching?\rWe have not yet performed a large-scale test on students, but we believe that the system may indeed be used in this capacity. Installation is straightforward and the system functions on Linux, macOS and Windows. The automation is push-button style without needing any configuration, and when a proof cannot be found, Tactician can still suggest tactics that may be useful.\nI have a great Machine Learning idea; can I implement it on top of Tactician?\rYes! Tactician is an extensible platform that can incorporate multiple machine learning models and search procedures. If you want to contribute your ideas, you can either work on the Tactician code-base directly, or you can create a plugin for Tactician in a separate repository. We are always searching for people that want to develop new ideas, either independently or in collaboration with us. If you\u0026rsquo;d like more information, please reach out to us!\nHow good is Tactician?\rAs of January 2024, several of Tactician\u0026rsquo;s models provide state-of-the-art proving performance. Evaluated over a wide range of Coq developments, the best models can prove up to 26% of theorems fully automatically. This outperforms all other provers we have made comparisons to. Performance between individual Coq packages fluctuates wildly. The best models as of 2024 are the built-in k-nearest neighbor model and Graph2Tac. The Graph2Tac paper contains an extensive analysis of the performance of several models.\nWhat tools related to Tactician exist?\rCoqHammer is an automated reasoning tool for Coq. It translates Coq\u0026rsquo;s Calculus of Constructions into first-order logic and calls several external automatic theorem provers to prove a goal. When the external prover succeeds, an CoqHammer attempt to reconstruct this proof within Coq. Although CoqHammer and Tactician have similar goals (automatically proof lemmas for Coq), their way of achieving this goal is quite different. As such, it has been shown before that these tools are quite complementary and we highly recommend you try CoqHammer out. "
  },
  {
    "url": "https://coq-tactician.github.io/categories/",
    "title": "Categories",
    "description": "",
    "content": ""
  },
  {
    "url": "https://coq-tactician.github.io/changelog/",
    "title": "Changelog posts",
    "description": "",
    "content": "Announcing Graph2Tac, a prover based on Tactician\u0026rsquo;s API for external agents We are pleased to announce Tactician\u0026rsquo;s API, a new AI interface for theorem proving, building on Tactician. This includes a new graph-based dataset of over 520k definitions (of which 260k are theorems) in 120 Coq packages, one of the largest datasets for AI interactive theorem proving. We also present a new state-of-the-art neural theorem proving solver Graph2Tac, designed for proving theorems in Coq projects with new definitions not seen during training.\nThe main contributions in this work are as follows:\nA novel method of calculating an internal representation of definitions and theorems, giving Graph2Tac a deeper semantic understanding of a proof state and which lemmas are appropriate for it. Graph2Tac is able to create representations of objects that were not seen during training, allowing it to perform well even on new Coq projects. One of the most comprehensive studies yet of various AI methods in interactive theorem proving including k-NN solvers, transformers, graph-based models, and hammers. An interface to Coq making it possible to train and connect your own custom machine learning models. A benchmarking system making it easy to give an apples-to-apples comparison to our work. For Coq users, our neural models Graph2Tac and Text2Tac, are available as part of Tactician and can be run on a laptop (no GPU required). One can use Tactician\u0026rsquo;s Suggest command to suggest tactics, and synth tactic to find a complete proof of a proof state.\nThe details are spelled out in these three papers:\nGraph2Tac: Learning Hierarchical Representations of Math Concepts in Theorem proving The Tactician’s Web of Large-Scale Formal Knowledge Hashing Modulo Context-Sensitive α-Equivalence Dataset: Our dataset, which can be explored online, faithfully represents the internal representation of Coq\u0026rsquo;s universe of mathematical knowledge as a single interconnected graph. The visualization includes hierarchies of modules, global context information, definitions, tactical proofs, and tactic proof transformations.\nThe dataset contains two representations. The text-based, human-readable representation is useful for training language models. The graph-based representation is designed such that two terms are alpha-equivalent terms if and only if their the forward closure of their graphs are equivalent (bisimilar). This allows us to merge alpha-equivalent subterms, heavily compressing the dataset. Having a densely connected graph makes it ideal for graph-based machine learning models. To support this term-sharing, we introduce a novel graph sharing algorithm with O(n log n) complexity.\nGraph2Tac: In practical AI theorem proving, one of the main challenges is handing new definitions and theorems not seen during training. We want to have a model which can work online, adapting itself to users\u0026rsquo; new projects in real time, so we train on one set of projects and test on another set never seen during training. Our novel neural theorem proving architecture, Graph2Tac, adds a new definition task mechanism which improves theorems solved from 17.4% to 26.1%. For example, even though our model has never before seen the Poltac package, it is able to solve 86.7% of Poltac theorems, more than any other Coq theorem prover in the literature, including ProverBot9001 and CoqHammer.\nOur definition task works by learning an embedding for each definition and theorem in the training set, and then simultaneously training a model to predict those learned embeddings. At inference time, when we encounter a new definition not seen during training, we use this definition task to compute its embedding directly.\nOur work contains one of the most extensive comparisons with other proving methods, including CoqHammer, a baseline transformer, and Tactician\u0026rsquo;s built-in k-NN model. The transformer model is similar to those used in GPT-f, PACT, Lisa, etc. The k-NN model is also an online model, learning from proofs or recent theorems, and is actually still a really good model for short time periods, say one minute, whereas Graph2Tac excels at the longer 10 minute mark. Appendix H of our paper also provides an informal comparison with Proverbot9001 and CoqGym family of solvers. We hope these comparisons will provide a lot of discussion and move the field forward.\nTools for AI research We provide a lot of tools for AI researchers who would like to compare with or build on our results and for Coq developers who would like to build practical tools for Coq users.\nInteraction protocols: External agents can interface with Coq, either by providing tactic predictions for Tactician’s search procedure for the synth tactic, or by exploring the proof tree themselves through the Tactician\rExplore command. Agents receive a full copy of Coq’s internal kernel knowledge, which they can utilize to make decisions.\nPyTactician: A Python library to facilitate reading the dataset and interface with Coq.\nBenchmarking: Tools to evaluate the proving strength of agents on arbitrary Opam packages. Benchmarks can be run on a laptop, a high-powered server and even massively parallelized on a High Perfomance Computing (HPC) cluster.\nWe would love to receive feedback both from Coq users and AI researchers, including possible future collaborators!\nLasse Blaauwbroek, Jason Rute, Miroslav Olšák, Fidel Ivan Schaposnik Massolo, Jelle Piepenbrock, Vasily Pestun\nAnnouncing Tactician version 1.0 beta2 After almost three years of development, we are happy to announce Tactician 1.0 beta2. It is available for all Coq versions between v8.12 and v8.18. Tactician is a proof synthesis system that uses data from existing theorems in order to help users write new proofs. It can adapt to, and learn from new developments on the fly. For details, see the website and the list of publications.\nMost of the development time in the past three years went to bug fixes, stability improvements, performance improvements and other internal changes. No detailed changelog was kept, but we believe the usability has improved significantly. There have also been a number of important user-facing changes:\nThe search tactic has been renamed to synth to avoid confusion with Coq\u0026rsquo;s internal Search command. (The Suggest command remains the same.)\nStarting from Coq v8.17, the standard library has been split from Coq\u0026rsquo;s core, resulting in the packages coq-core and coq-stdlib. The coq-tactician package now depends only coq-core. This allows Tactician to instrument coq-stdlib while it is being installed in order to learn from it, obviating the need for the coq-tactician-stdlib package. (See the manual for further instructions.)\nIn the past years, the landscape of available Coq editors has changed significantly. The support for the various editors is as follows:\nCoqide: Fully supported. Emacs with Proof General: Fully supported. Coq-lsp: Partially supported. Tactician can be loaded through From Tactician Require Import Ltac1, but support for injecting Tactician through launching VsCode with tactician exec code is unavailable. VsCoq Legacy: Supported. Support for launching VsCode through tactician exec code is available starting Coq v8.12. VsCoq 2.0: Currently incompatible with Tactician. If you encounter any issues with these editors, please open an issue.\nTactician is now fully open source under the MIT license. As such, this is an invitation for other researchers to use the data available in Tactician to build their own proof synthesizer. If you have a great idea, don\u0026rsquo;t hesitate to reach out for a potential collaboration.\nAny feedback on this beta release is appreciated. Do not hesitate to open an issue.\nAnnouncing Tactician version 1.0 beta1 We would like to announce Tactician 1.0 beta1, the first official release of Tactician. Tactician is a tactic learner and prover for the Coq Proof Assistant. The system will help users make tactical proof decisions while they retain control over the general proof strategy. To this end, Tactician will learn from previously written tactic scripts, and either gives the user suggestions about the next tactic to be executed or altogether takes over the burden of proof synthesis. Tactician’s goal is to provide the user with a seamless, interactive, and intuitive experience together with strong, adaptive proof automation.\nEven though a lot still remains to be done, with this version we believe that the system is mature enough to be used in real developments. We would like to solicit any feedback on the system you might have. Feel free to open issues in the issue tracker.\nTactician is available for Coq v8.11, v8.12, v8.13 and master and on Linux, macOS and Windows. Installation instructions can be found in the manual. An online demo can be found here. Tactician has first-class support for Opam, and can automatically learn from almost any Coq package. For the exceptions, special support can be added. Currently, special support exists for the HoTT homotopy type theory library. If tactician cannot instrument your favorite package and you would like to see support, please open an issue.\nThis release contains too many features and improvements to list exhaustively. We invite you to explore the system on your own and find them yourself. However, a sneak-peak of significant improvements are tactic discharging for sections and local parameter prediction.\nFuture direction This release of Tactician is aimed at providing Coq users with an easy to use system that can be used in real Coq developments. The next step in our grand plan is to transform Tactician into a machine learning platform, where AI-researchers can add agents to Tactician (a plugin for a plugin) using an easy-to-use API. The goal of this API is to take away the hard Coq engineering problems and only leave the hard machine learning problems.\nThis API is still under heavy development. We are therefore not yet inviting the wider AI-community to work with Tactician. However, we are looking for collaborators/beta-testers. So if you have a good machine learning idea that you would like to implement on top of Tactician, please get in touch.\n"
  },
  {
    "url": "https://coq-tactician.github.io/tags/",
    "title": "Tags",
    "description": "",
    "content": ""
  },
  {
    "url": "https://coq-tactician.github.io/",
    "title": "The Tactician",
    "description": "",
    "content": ""
  }]